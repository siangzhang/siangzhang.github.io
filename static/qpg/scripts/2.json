{
"name": "Shor's Algorithm - libquantum",
"content": "// QScript version of an example from libquantum library.\n \n num_regs = 4\n \n proc swaptheleads width\n   for i = 0; i < width; i++\n     CNot i, width + i\n     CNot width + i, i\n     CNot i, width + i\n   endfor\n endproc\n \n proc swaptheleads_omuln_controlled control, width\n   for i = 0; i < width; i++\n     Toffoli control, width + i, 2 * width + i + 2\n     Toffoli control, 2 * width + i + 2, width + i\n     Toffoli control, width + i, 2 * width + i + 2\n     endfor\n endproc\n \n proc test_sum compare, width\n   if compare & (1 << (width - 1))\n     CNot 2 * width - 1, width - 1\n     SigmaX 2 * width - 1\n     CNot 2 * width - 1, 0\n   else\n     SigmaX 2 * width - 1\n     CNot 2 * width - 1, width - 1\n   endif\n   for i = (width - 2) ; i > 0; i--\n     if compare & (1 << i) //is bit i set in compare?\n       Toffoli i + 1, width + i, i\n       SigmaX width + i\n       Toffoli i + 1, width + i, 0\n     else\n       SigmaX width + i\n       Toffoli i + 1, width + i, i\n     endif\n   endfor\n   if compare & 1\n     SigmaX width\n     Toffoli width, 1, 0\n   endif\n   Toffoli 2 * width + 1, 0, 2 * width //set output to 1 if enabled and b < compare\n \n   if compare & 1\n     Toffoli width, 1, 0\n     SigmaX width\n   endif\n \n   for i = 1; i <= (width - 2) ; i++\n     if compare & (1 << i) //is bit i set in compare?\n       Toffoli i + 1, width + i, 0\n       SigmaX width + i\n       Toffoli i + 1, width + i, i\n     else\n       Toffoli i + 1, width + i, i\n       SigmaX width + i\n     endif\n   endfor\n   if compare & (1 << (width - 1))\n     CNot 2 * width - 1, 0\n     SigmaX 2 * width - 1\n     CNot 2 * width - 1, width - 1\n   else\n     CNot 2 * width - 1, width - 1\n     SigmaX 2 * width - 1\n   endif\n endproc\n \n // This is a semi-quantum fulladder. It adds to b_in\n // a c-number. Carry-in bit is c_in and carry_out is\n // c_out. xlt-l and L are enablebits. See documentation\n // for further information\n \n proc  muxfa a, b_in, c_in, c_out, xlt_l, L, total //a,\n \n   if a == 0//00\n     Toffoli b_in, c_in, c_out\n     CNot b_in, c_in\n   endif\n \n   if a == 3//11\n     Toffoli L, c_in, c_out\n     CNot L, c_in\n     Toffoli b_in, c_in, c_out\n     CNot b_in, c_in\n   endif\n \n   if a == 1//01\n     Toffoli L, xlt_l, b_in\n     Toffoli b_in, c_in, c_out\n     Toffoli L, xlt_l, b_in\n     Toffoli b_in, c_in, c_out\n     Toffoli L, xlt_l, c_in\n     Toffoli b_in, c_in, c_out\n     CNot b_in, c_in\n   endif\n \n   if a == 2//10\n     SigmaX xlt_l\n     Toffoli L, xlt_l, b_in\n     Toffoli b_in, c_in, c_out\n     Toffoli L, xlt_l, b_in\n     Toffoli b_in, c_in, c_out\n     Toffoli L, xlt_l, c_in\n     Toffoli b_in, c_in, c_out\n     CNot b_in, c_in\n     SigmaX xlt_l\n   endif\n endproc\n \n  // This is just the inverse operation of the semi-quantum fulladder\n \n proc muxfa_inv a, b_in, c_in, c_out, xlt_l, L, total //a,\n   if a == 0//00\n     CNot b_in, c_in\n     Toffoli b_in, c_in, c_out\n   endif\n \n   if a == 3//11\n     CNot b_in, c_in\n     Toffoli b_in, c_in, c_out\n     CNot L, c_in\n     Toffoli L, c_in, c_out\n   endif\n \n   if a == 1//01\n     CNot b_in, c_in\n     Toffoli b_in, c_in, c_out\n     Toffoli L, xlt_l, c_in\n     Toffoli b_in, c_in, c_out\n     Toffoli L, xlt_l, b_in\n     Toffoli b_in, c_in, c_out\n     Toffoli L, xlt_l, b_in\n   endif\n \n   if a == 2//10\n     SigmaX xlt_l\n     CNot b_in, c_in\n     Toffoli b_in, c_in, c_out\n     Toffoli L, xlt_l, c_in\n     Toffoli b_in, c_in, c_out\n     Toffoli L, xlt_l, b_in\n     Toffoli b_in, c_in, c_out\n     Toffoli L, xlt_l, b_in\n     SigmaX xlt_l\n   endif\n endproc\n \n // This is a semi-quantum halfadder. It adds to b_in\n // a c-number. Carry-in bit is c_in and carry_out is\n // not necessary. xlt-l and L are enablebits. See\n // documentation for further information\n \n proc muxha a, b_in, c_in, xlt_l, L, total //a,\n   if a == 0//00\n     CNot b_in, c_in\n   endif\n \n   if a == 3//11\n     CNot L, c_in\n     CNot b_in, c_in\n   endif\n \n   if a == 1//01\n     Toffoli L, xlt_l, c_in\n     CNot b_in, c_in\n   endif\n \n   if a == 2//10\n     SigmaX xlt_l\n     Toffoli L, xlt_l, c_in\n     CNot b_in, c_in\n     SigmaX xlt_l\n   endif\n endproc\n \n // just the inverse of the semi quantum-halfadder\n \n proc muxha_inv a, b_in, c_in, xlt_l, L, total //a,\n   if a == 0//00\n     CNot b_in, c_in\n   endif\n \n   if a == 3//11\n     CNot b_in, c_in\n     CNot L, c_in\n   endif\n \n   if a == 1//01\n     CNot b_in, c_in\n     Toffoli L, xlt_l, c_in\n   endif\n \n   if a == 2//10\n     SigmaX xlt_l\n     CNot b_in, c_in\n     Toffoli L, xlt_l, c_in\n     SigmaX xlt_l\n   endif\n endproc\n \n //\n \n proc madd a, a_inv, width\n   total = num_regs * width + 2\n   for i = 0; i < width - 1; i++\n     if (1 << i) & a\n       j = 1 << 1\n     else \n       j = 0\n     endif\n     if (1 << i) & a_inv\n       j += 1\n     endif\n     muxfa j, width + i, i, i + 1, 2 * width, 2 * width + 1, total\n   endfor\n   j = 0\n   if (1 << (width - 1)) & a\n     j = 2\n   endif\n   if (1 << (width - 1)) & a_inv\n     j += 1\n   endif\n   muxha j, 2 * width - 1, width - 1, 2 * width, 2 * width + 1, total\n endproc\n \n proc madd_inv a, a_inv, width\n   total = num_regs * width + 2\n   j = 0\n \n   if (1 << (width - 1)) & a\n     j = 2;\n   endif\n   if (1 << (width - 1)) & a_inv\n     j += 1;\n   endif\n   muxha_inv j, width - 1, 2 * width - 1, 2 * width, 2 * width + 1, total\n \n   for i = width - 2; i >= 0; i--\n     if (1 << i) & a\n             j = 1 << 1\n     else\n       j = 0\n     endif\n     if (1 << i) & a_inv\n       j += 1\n     endif\n     muxfa_inv j, i, width + i, width + 1 + i, 2 * width, 2 * width + 1, total\n   endfor\n endproc\n \n proc addn N, a, width //add a to register reg (mod N)\n   test_sum N - a, width //xlt N-a\n   madd (1 << (width)) + a - N, a, width //madd 2^K+a-N\n endproc\n \n proc addn_inv N, a, width //inverse of add a to register reg (mod N)\n   CNot 2 * width + 1, 2 * width //Attention! cnot gate instead of not, as in description\n   madd_inv (1 << (width)) - a, N - a, width //madd 2^K+(N-a)-N = 2^K-a\n \n   swaptheleads width\n \n   test_sum a, width\n endproc\n \n proc add_mod_n N, a, width //add a to register reg (mod N) and clear the scratch bits\n   addn N, a, width\n   addn_inv N, a, width\n endproc\n \n proc emul a, L, width\n   for i = width - 1; i >= 0; i--\n     if (a >> i) & 1\n      Toffoli 2 * width + 2, L, width + i\n     endif\n   endfor\n endproc\n \n proc muln N, a, ctl, width //ctl tells, which bit is the external enable bit\n   L = 2 * width + 1\n \n   Toffoli ctl, 2 * width + 2, L\n \n   emul a % N, L, width\n \n   Toffoli ctl, 2 * width + 2, L\n \n   for i = 1; i < width; i++\n     Toffoli ctl, 2 * width + 2 + i, L\n     add_mod_n N, ((1 << i) * a) % N, width\n     Toffoli ctl, 2 * width + 2 + i, L\n   endfor\n endproc\n \n proc muln_inv N, a, ctl, width //ctl tells, which bit is the external enable bit\n   L = 2 * width + 1\n \n   a = QMath.inverseMod(N, a)\n \n   for i = width - 1; i > 0; i--\n     Toffoli ctl, 2 * width + 2 + i, L\n     add_mod_n N, N - ((1 << i) * a) % N, width\n     Toffoli ctl, 2 * width + 2 + i, L\n   endfor\n \n   Toffoli ctl, 2 * width + 2, L\n   emul a % N, L, width\n   Toffoli ctl, 2 * width + 2, L\n endproc\n \n proc mul_mod_n N, a, ctl, width\n   muln N, a, ctl, width\n \n   swaptheleads_omuln_controlled ctl, width\n \n   muln_inv N, a, ctl, width\n endproc\n \n proc exp_mod_n N, x, width_input, width\n   SigmaX 2 * width + 2\n   for i = 1; i <= width_input; i++\n     f = x % N     //compute\n     for j = 1; j < i; j++\n       f *= f    //x^2^(i-1)\n       f = f % N\n     endfor\n     mul_mod_n N, f, 3 * width + 1 + i, width\n   endfor\n endproc\n \n proc FindFactors N\n   x = 0\n \n   if N < 15\n     Print \"Invalid number!\"\n     Breakpoint\n   endif\n \n   width = QMath.getWidth(N * N)\n   swidth = QMath.getWidth(N)\n \n   for x; (QMath.gcd(N, x) > 1) || (x < 2); x\n     x = Math.floor(Math.random() * 10000) % N\n   endfor\n \n   Print \"Random seed: \" + x\n \n   for i = 0; i < width; i++\n     Hadamard i\n   endfor\n \n   ShiftLeft 3 * swidth + 2\n \n   exp_mod_n N, x, width, swidth\n \n   for i = 0; i < 3 * swidth + 2; i++\n     MeasureBit i\n   endfor\n \n   ShiftRight 3 * swidth + 2\n \n   InvQFT 0, width\n \n   for i = 0; i < width / 2; i++\n     CNot i, width - i - 1\n     CNot width - i - 1, i\n     CNot i, width - i - 1\n   endfor\n \n   for trycnt = 100; trycnt >= 0; trycnt--\n     Measure\n     c = measured_value\n \n     if c == 0\n       Print \"Measured zero, try again.\"\n       continue\n     endif\n \n     q = 1 << width\n \n     Print \"Measured \" + c + \" (\" + c / q + \")\"\n \n     tmp = QMath.fracApprox(c, q, width)\n \n     c = tmp[0];\n     q = tmp[1];\n \n     Print \"fractional approximation is \" + c + \"/\" + q\n \n     if (q % 2 == 1) && (2 * q < (1 << width))\n       Print \"Odd denominator, trying to expand by 2.\"\n       q *= 2\n     endif\n \n     if q % 2 == 1\n       Print \"Odd period, try again.\"\n       continue\n     endif\n \n     Print \"Possible period is \" + q\n \n     a = QMath.ipow(x, q / 2) + 1 % N\n     b = QMath.ipow(x, q / 2) - 1 % N\n \n     a = QMath.gcd(N, a)\n     b = QMath.gcd(N, b)\n \n     if a > b\n       factor = a\n     else\n       factor = b\n     endif\n \n     if (factor < N) && (factor > 1)\n       Display \"<h2>Success: \" + factor + \" \" + N / factor\n       Breakpoint\n     else\n       Print \"Unable to determine factors, try again.\"\n       continue\n     endif\n   endfor\n endproc\n \n VectorSize 22\n FindFactors 15"
}